---
title: 数据库-索引
tags:
  - 总结
  - MySQL
categories:
  - MySQL
#keywords: "hello 1"
cover: https://pic.imgdb.cn/item/65e21e529f345e8d0387b178.webp
toc: True
abbrlink: 8
---

# 目的
- 索引的出现是为了提高数据查询的效率，就像书的目录一样。索引是一种特殊的文件，包含对数据表中所有记录的引用指针，通常使用B树及其变种B+树
# 索引的优缺点
## 优点
   - 可以加快查询速度
   - 可以在查询中使用优化隐藏器，提高系统性能
## 缺点
   - 创建和维护索引需要耗费时间，降低增删改的执行效率
   - 需要占用物理空间。
# 索引的常见模型
## 基本概念
 - 实现索引的方式有很多，可用于提高读写效率的数据结构也很多，下面从使用的角度介绍三个比较常用、简单的数据结构的区别：哈希表、有序数组和搜索树。
   - 哈希表是把key用哈希函数放到一个确定的位置，然后把value放在数组的这个位置，当多个key换算成同一个位置，则使用链表存储，查询的时候遍历链表即可。但是哈希表做区间查询速度慢，适用于只有等值查询的场景，比如Memcached以及其他一些NoSQL引擎。
   - 有序数组在等值查询和范围查询中的性能都很优秀，递增的ID可通过二分法快速查询。但是在更新数据时的时间复杂度会是On，所以有序数组只适用于静态存储引擎，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。
   - 二叉搜索树查询更新复杂度都是logn。虽然二叉树效率是最高的，但是实际上大多数数据库并不用二叉树，原因是索引不止在内存中，还要写到磁盘上。想象一下，一棵100万个节点的平衡二叉树，树高20，一次查询可能就要访问20个数据块，这样查询效率就低了。因此为了让一个查询尽量少读磁盘，就必须让查询过程访问尽量少的数据块，而磁盘查找存取的次数往往由树的高度所决定。那就应该使用“N叉树”，N取决于数据块的大小。
   - 以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。
   - N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。
# TODO:索引的分类
# MySQL支持的索引类型
# B+Tree
# 什么时候需要索引/不需要索引
# InnoDB 的索引模型
## 基本概念
- 在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。每个索引在InnoDB里面对应一棵B+树。
- 根据叶子节点的内容，索引类型分为主键索引和非主键索引。
  - 主键索引的叶子节点存储的是整行数据。在InnoDB里，主键索引也被称为聚簇索引。
  - 非主键索引的叶子节点存储的是主键的值。在InnoDB里，非主键索引也成为二级索引。
- 基于主键索引和普通索引的查询有什么区别？
  - 假设语句是select * from T where ID = 500 ，即主键查询方式，则只需要搜索ID这棵B+树。
  - 假设语句是select * frome T where K = 5，即普通索引查询方式，则需要先搜索K索引树，得到对应的ID，再到ID索引树搜索依次。这个过程称为回表。也就是说，基于非主键索引的查询需要多扫描一棵索引树，因此在应用中应该尽量使用主键查询。
## 索引维护
- 基本概念
  - B+树为了维护索引有序性，在插入新值的时候需要维护。
  - 哪些场景下应该使用自增主键，而哪些场景下不应该。
    - 自增主键是指自增列上定义的主键，在建表语句中一般这么定义：NOT NULL PRIMARY KEY AUTO_INCREMENT。插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加一作为下一条记录的ID值。也就是说，每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发B+树叶子节点的分裂。并且每个非主键索引的叶子节点都是主键的值，假如主键是其他数据类型而非整型之类，则可能会使得普通索引占用的空间更大。因此从性能和存储空间方面考量，自增主键往往是更合理的选择。
    - 适合用业务字段直接做主键的场景
      - 比如场景需求如下：1、只有一个索引；2、该索引必须是唯一索引。也就是典型的KV场景。由于没有其他索引，所以也就不用考虑其他索引的叶子节点的大小问题。这时候就需要考虑到“尽量使用主键查询”的原则，直接将这个索引设置为主键，避免每次查询需要搜索两棵树。
# 索引优化
## 如何避免回表过程？
 - 覆盖索引
   - 假如对于非主键索引的查询，只要查ID的值，而ID的值已经在非主键索引树上了，因此可以直接提供查询结果，避免了回表操作，对于SQL中query的所有字段，在索引B+Tree的叶子节点上都能找到的索引，称为覆盖索引。
 - 最左前缀原则
   - 基本概念
     - 最左匹配原则是说在通过联合索引检索数据时，从索引中最左边的列开始，一直向右匹配，如果遇到范围查询（<> between like等），就停止后边的匹配。
     - 建立联合索引时，可以将选择性高的列放在索引的最前列，选择性低的放后边。在一些大字符串的字段作为索引时，使用前缀索引可以减少索引项的大小，因为不用再对大字符串字段单独建立索引了。
   - 使用到索引/未使用的情形
     - 总结：什么情况下会索引失效？
       - 当索引列出现以下六种操作时常常出现索引失效：
         - 1、使用函数（replace\SUBSTR\CONCAT\sum count avg）、表达式、计算（+ - * /）。因为当前值改变后就无法与索引存的值匹配上。
           - 为什么这些SQL语句逻辑相同，性能却差异巨大？（本节只是起到举一反三的作用，具体问题具体分析）（本质考点是索引失效的原因分析）
             - 条件字段函数操作
               - eg mysql> select count(*) from tradelog where month(t_modified)=7;
               - 对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器放弃走树搜索功能，只能使用全索引扫描
             - 隐式类型转换
               - egselect * from tradelog where tradeid=110717;
               - 这里面tradeid字段类型是varchar（32），而输入的参数却是整型，所以需要做类型转换。
               - MySQL中，字符串和数字作比较的话，是将字符串转换成数字，这样会将索引字段做一个函数操作，从而使得优化器放弃走树搜索功能
             - 隐式字符编码转换
               - 假如一个表是utf8，另一个是utf8-mb4，在做表连接查询的时候用不上关联字段的索引，因为也会调用convert函数将字符串转换成utf8mb4字符集。
             - 以上原因总结起来均是在索引字段上使用了函数，因此优化方法是想办法将函数加在输入参数上，这样就可以用上索引了。
         - 2、使用范围查询(!=,<=>,in)会导致右边列失效。因为二叉树的查找是 = 查找，若是一个范围的话无法继续下探。
           - 最左列用范围，该列也不会使用索引，全部索引列失效
           - 其余列用范围，当前列仍会使用索引，但右边索引列失效
           - SELECT * FROM user_innodb where name='张三' and age > 22；
         - 3、like以通配符开头（‘%abc…’），mysql索引失效会变成全表扫描操作。因为无法判断%代表多少字符。
           - 方案一：like (‘abc%’)
           - 方案二：覆盖索引
             - SELECT * FROM user_innodb where name like '%三'；
         - 4、字符串不加’ '索引失效。因为会出现出现隐式转换，相当于给索引列做了操作。
           - SELECT * FROM user_innodb where name = 007；-- "007"从字符串变成了数字007
         - 5、少用or，用它连接时很多情况下索引会失效
           - SELECT * FROM user_innodb where name = '张三' or name = '李四'；
         - 6、is null，is not null 无法使用索引
           - SELECT * FROM user_innodb where name is null；
         - 总结打油诗
           - 全值匹配我最爱，最左前缀要遵守
             - 带头大哥不能死，中间兄弟不能断
             - 索引列上少计算，范围之后全失效
             - like百分写最右，覆盖索引不写星
             - 不等空值还有or，索引失效要少用
       - 可以乱序
         - 比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序。
   - 索引下推
     - 基本概念
       - 索引下推ICP是MySQL5.6版本的新特性，它能够减少回表查询次数，提高查询效率
     - 实现原理
       - 在没有ICP的情况下，查询过程如下：
         - 存储引擎读取索引记录，回表，将全部记录交给服务层检测是否满足where条件
       - 使用ICP后的查询过程：
         - 存储引擎读取索引记录，判断条件部分能否使用索引中的列做检查，条件不满足，则处理下一行索引记录；条件满足则回表，然后交给服务层检测其余条件。显然这样会减少回表次数。
 - 插入优化
   - 索引最好是自增的，如果不自增，因B+树要求需要按主键顺序排列，再插入新数据的时候会产生大量的数据移动。



