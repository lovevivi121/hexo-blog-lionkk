---
title: 数据库-基本架构
tags:
  - 总结
  - MySQL
categories:
  - MySQL
cover: https://pic.imgdb.cn/item/65e21e529f345e8d0387b178.webp
toc: True
abbrlink: 4
---
# 大体上MySQL可以分为Server层和引擎层两个部分
# Server层
  - Server层包括连接器、查询缓存、分析器、优化器、执行器，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
    # 连接器
      - 基本概念
        -  当客户端连接到数据库上的时候，首先接待的便是连接器，连接器负责跟客户端建立连接，获取权限，维持和管理连接。
      - 连接流程
        - 连接的命令如下```-h$ip -p$port -u$user -p``` 接着输入密码。完成TCP握手后连接器就会开始身份认证。如果用户或者密码不对就会报```Access denied for user```错误，客户端结束运行。如果认证通过，接下来连接器会到权限表里面获取当前用户的所有权限。之后该连接的所有权限判断都依据当前获取的权限，意味着即使权限被修改了，也需要重新连接才能使用新的权限。
        - 完成连接后，如果没有操作该连接便会进入空闲状态，可在show processlist里面查看连接的状态。如果连接超过wait_timeout时间没有动作，默认是8小时，则会将连接断开，如果此时再发起请求将会报```Lost connection to MySQL server during query```错误。
      - 长连接与短链接
        - 基本概念
          - 长连接是指如果客户端一直有请求则一直使用该连接。短连接是指每次执行过很少请求后就断开连接，下次查询再重新连接。由于连接过程复杂，所以推荐使用长连接。
        - 长连接的问题与解决方案
          - 问题提出
            - MySQL执行过程中使用的内存是在连接内部的，这些资源会在连接断开的时候才释放。如果使用长连接，积累过多了会导致内存暴涨，这个时候系统会强行kill连接，表现出来就是MySQL异常重启了。
          - 解决方案
            - 一个是定期断开长连接，或者执行了一个占用内存大的查询后，断开连接并重连。
            - 另一个是5.7版本后可以使用```mysql_reset_connection```重新初始化连接资源,不用断开连接。
    # 查询缓存
      - 基本概念
        - 建立连接后执行逻辑会来到查询缓存。MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个value 就会被直接返回给客户端。如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。但是查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。
      - 按需使用
        -  MySQL 提供了“按需使用”的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：mysql> select SQL_CACHE * from T where ID=10；
        - MySQL 8.0 版本直接将查询缓存的整块功能删掉了。
    # 分析器
      - 基本概念
        - 如果没有命中查询缓存，则接下来要开始真正执行语句了。首先MySQL需要知道你要做什么，因此需要对SQL语句做解析。
      - 语句解析分为了词法分析和语法分析
        - 词法分析
          - 分析的是SQL语句的字符串中分别是什么，代表什么。比如select就标识为查询语句，ID识别为列ID等
        - 语法分析
          - 是用来判断SQL语句是否满足MySQL语法，如果不满足则报You have an error in your SQL syntax错误
    # 优化器
      - 在开始执行前，还要经过优化器处理。优化器是在表里面有多个索引的时候，决定使用哪个索引，或者在一个语句有多个表关联（join）时，决定各表的连接顺序，这些都会导致执行效率的不同。

    # 执行器
      - 接下来就是进入执行器阶段，开始执行语句。
      - 基本流程
        - 开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误。如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。
        - 比如我们要查询表 T 中ID为10的数据，并且ID 字段没有索引，那么执行器的执行流程是这样的：1. 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；2. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。
        - 对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。
        - 在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。
  # 存储引擎
  - 什么是存储引擎？
    - 存储引擎层负责数据的存储和提取，直接与磁盘交互部分。页是存储引擎读写数据的最小单位，一个页里可以有一条或多条表记录。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎，而 InnoDB 是 MySQL 中唯一能够完整支持事务特性的存储引擎。你执行 create table 建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在 create table语句中使用 engine=memory, 来指定使用内存引擎创建表。
  - 什么是随机 IO 和顺序 IO？
    - 磁盘读写数据的两种方式。随机 IO 需要先找到地址，再读写数据，每次拿到的地址都是随机的。而顺序 IO，由于地址是连贯的，找到地址后，一次可以读写许多数据，效率比较高。










