---
title: 数据库-事务隔离
tags:
  - 总结
  - MySQL
categories:
  - MySQL
#keywords: "hello 1"
cover: https://cdn.jsdelivr.net/gh/HCLonely/hclonely.github.io/img/Butterfly/006.webp
toc: True
abbrlink: 7
---
# 事务的基本概念
  - 事务就是保证一组数据库操作，要么全部成功，要么全部失败。在MySQL中，事务支持实在引擎层实现的，其中MyISAM引擎不支持事务。
# 隔离性与隔离级别
## 基本概念
- 事务有4大特性ACID，分别是原子性、一致性、隔离性、持久性，隔离性便是其中之一。
- 当数据库上有多个事务在同时执行时，可能出现脏读、不可重复读、幻读（TODO：解释这三个名词）的问题，为了解决这些问题，引出了“隔离级别”的概念。隔离得越严实，效率就会越低，因此需要在二者之间找到平衡。
- SQL标准的事务隔离级别包括：读未提交、读提交、可重复读和串行化。
  - 读未提交是指其他事务能够读到一个没有提交的事务的变更。
  - 读提交是指其他事务能够读到一已提交的事务的变更。
  - 可重复读是指一个事务执行过程中读到的数据总是和事务启动时读到的一致。
  - 串行化是指对于同一行记录，写加写锁，读加读锁，多个写操作串行访问。
## 视图
  - 在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑为准。在“可重复读”隔离级别下，这个视图是在事务启动的时候创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行时创建的。需要注意的是，对于“读未提交”隔离级别，是直接返回记录的最新值，没有视图的概念。而“串行化”隔离级别下直接用加锁的方式来避免并行访问。MySQL通过设置transaction_isolation参数修改隔离级别。
## 应用场景
- 可重复读
  - 比如希望在进行数据分析处理的过程中，不受其他事务更新的影响，就可以用“可重复读”隔离级别。
## 事务隔离的实现
  - 以可重复读为例子。在MySQL中实际上每条记录在更新时都会同时记录一条回滚操作，记录上的最新值可通过回滚得到前一个状态的值。同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。不同的视图通过回滚操作得到。当系统里面没有比当前回滚日志更早的视图时，回滚日志就会删除。
## 为什么建议不要使用长事务？
  - 长事务意味着系统里面存在很老的事务视图。由于这些食物随时会访问数据库里面任何数据，因此在十五提交前，数据库里面它可能用到的回滚记录都必须保留，这样会导致占用大量存储空间。并且长事务占用所资源，也可能拖垮整个库。
  - 你可以在 information_schema 库的 innodb_trx 这个表中查询长事务
## 事务的启动方式
  - MySQL的启动方式有以下几种：
    - 1、显示启动事务语句，begin或者start transaction。配套的提交语句时commit，回滚语句时rollback。
    - 2、set autocommit=0，这个命令会将这个线程的自动提交关掉，意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit或者rollback语句，或者断开连接。
    - 在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。




